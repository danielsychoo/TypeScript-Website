{"componentChunkName":"component---src-templates-play-example-tsx","path":"/ko/play/javascript/working-with-classes/this.ts.html","result":{"pageContext":{"name":"This","title":"This","lang":"ko","html":"\n 클래스의 메서드를 호출할 때,\n 일반적으로 클래스의 현재 인스턴스를 참조할 것으로 예상합니다.\n\n<code><pre>\nclass Safe {\n  contents: string;\n\n  constructor(contents: string) {\n    this.contents = contents;\n  }\n\n  printContents() {\n    console.log(this.contents);\n  }\n}\n\nconst safe = new Safe(\"Crown Jewels\");\nsafe.printContents();\n\n</pre></code>\n// this/self를 쉽게 예상할 수 있는 객체지향언어 경험이 있다면\n 'this'가 얼마나 혼란스러울 수 있는지\n 확인할 필요가 있습니다:\n\n https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/\n https://aka.ms/AA5ugm2\n\n 짧은 요약: this는 바뀔 수 있습니다.\n 여러분이 함수를 어떻게 호출하는지에 따라 this 참조가 달라질 것입니다.\n\n 예를 들어,\n 다른 객체의 함수에 대한 참조를 사용하고 이를 호출하면\n this 변수는 호스팅 객체를 참조하도록 이동됩니다:\n\n<code><pre>\nconst customObjectCapturingThis = { contents: \"http://gph.is/VxeHsW\", print: safe.printContents };\ncustomObjectCapturingThis.print(); // \"Crown Jewels\"가 아닌 \"http://gph.is/VxeHsW\"를 출력합니다.\n\n</pre></code>\n// 콜백 API를 다룰 때, 함수 참조를 직접 전달하는 것이\n 매우 용이할 수 있지만 까다롭습니다.\n 호출 위치에서 새로운 함수를 생성함으로써\n 이 문제를 해결할 수 있습니다.\n\n<code><pre>\nconst objectNotCapturingThis = { contents: \"N/A\", print: () => safe.printContents() };\nobjectNotCapturingThis.print();\n\n</pre></code>\n// 문제를 해결하는 몇 가지 방법이 있습니다.\n 하나는 강제로 this 바인딩을\n bind를 통하여 원래 의도했던 객체로 만듭니다.\n\n<code><pre>\nconst customObjectCapturingThisAgain = { contents: \"N/A\", print: safe.printContents.bind(safe) };\ncustomObjectCapturingThisAgain.print();\n\n</pre></code>\n// 예기치 못한 이 context를 해결하기 위하여,\n 클래스에서 함수를 생성하는 방법을 변경할 수도 있습니다.\n 화살표 함수를 사용하는 프로퍼티를 만듦으로써,\n this의 바인딩은 다른 시간에 수행합니다.\n 따라서 덜 수행했던 context는 JavaScript 런타임에\n 더 예측할 수 있습니다.\n\n<code><pre>\nclass SafelyBoundSafe {\n  contents: string;\n\n  constructor(contents: string) {\n    this.contents = contents;\n  }\n\n  printContents = () => {\n    console.log(this.contents);\n  };\n}\n\n</pre></code>\n// 이제 실행하기 위해 다른 객체에 함수를 전달하는 것은\n 뜻하지 않게 this를 변경하지 않습니다.\n\n<code><pre>\nconst saferSafe = new SafelyBoundSafe(\"Golden Skull\");\nsaferSafe.printContents();\n\nconst customObjectTryingToChangeThis = {\n  contents: \"http://gph.is/XLof62\",\n  print: saferSafe.printContents,\n};\n\ncustomObjectTryingToChangeThis.print();\n\n</pre></code>\n// 여러분이 TypeScript 프로젝트를 갖고 있다면,\n TypeScript가 함수에 대한 \"this\"가 어떤 타입인지 결정할 수 없는 경우를\n 강조하기 위해서, 컴파일러 플래그 noImplicitThis를 사용할 수 있습니다.\n\n 여러분은 핸드북에서 더 자세히 배울 수 있습니다:\n\n https://www.typescriptlang.org/docs/handbook/utility-types.html#thistypet\n","redirectHref":"ko/play/?#example/this"}},"staticQueryHashes":[]}