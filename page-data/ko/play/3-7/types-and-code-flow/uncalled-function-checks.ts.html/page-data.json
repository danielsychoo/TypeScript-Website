{"componentChunkName":"component---src-templates-play-example-tsx","path":"/ko/play/3-7/types-and-code-flow/uncalled-function-checks.ts.html","result":{"pageContext":{"name":"Uncalled Function Checks","title":"Uncalled Function Checks","lang":"ko","html":"\n 3.7버전에서 새로운 점은 \n 여러분이 함수의 반환 값 대신 실수로 함수를 사용할 때,\n if문 내부를 검사하는 것입니다.\n\n if문을 항상 true로 만드는 함수가 존재한다고\n 알려질 때만 적용합니다.\n\n 여기에 선택적인 콜백과 필수적인 콜백이 있는\n plugin 인터페이스 예시가 있습니다.\n\n<code><pre>\ninterface PluginSettings {\n  pluginShouldLoad?: () => void;\n  pluginIsActivated: () => void;\n}\n\ndeclare const plugin: PluginSettings;\n\n</pre></code>\n// pluginShouldLoad는 존재하지 않으니\n 타당한 검사입니다.\n\n<code><pre>\nif (plugin.pluginShouldLoad) {\n  // pluginShouldLoad가 존재할 때 이곳에 당신이 원하는 것을 하세요.\n}\n\n// 3.6버전과 아래의 경우, 에러가 아닙니다.\n\nif (plugin.pluginIsActivated) {\n  // plugin이 활성화 될때\n  // 무언가를 하고 싶지만,\n  // 메서드 호출하는 대신에 속성으로 사용했습니다.\n}\n\n</pre></code>\n// pluginIsActivated는 항상 존재해야 하지만, \n if문 블록 안에서 메서드를 호출했으므로\n TypeScript는 여전히 검사를 허용합니다. \n\n<code><pre>\nif (plugin.pluginIsActivated) {\n  plugin.pluginIsActivated();\n}\n","redirectHref":"ko/play/?#example/uncalled-function-checks"}},"staticQueryHashes":[]}